import { AxiosResponse } from 'axios';
import http, { IncomingMessage } from 'node:http';
import https from 'node:https';
import { $URL } from 'ufo';
import * as lighthouse from 'lighthouse';
import { LH } from 'lighthouse';
import * as puppeteer_core from 'puppeteer-core';
import { LaunchOptions as LaunchOptions$1, Page as Page$1 } from 'puppeteer-core';
import { NestedHooks, Hookable } from 'hookable';
import { App } from 'h3';
import * as puppeteer from 'puppeteer';
import { Page, LaunchOptions, PuppeteerNodeLaunchOptions } from 'puppeteer';
import { EventEmitter } from 'events';
import { Socket } from 'node:net';
import { ConsolaInstance } from 'consola';

interface ClusterOptions {
  concurrency: number | unknown
  maxConcurrency: number
  workerCreationDelay: number
  puppeteerOptions: LaunchOptions
  perBrowserOptions: LaunchOptions[] | undefined
  monitor: boolean
  timeout: number
  retryLimit: number
  retryDelay: number
  skipDuplicateUrls: boolean
  sameDomainDelay: number
  puppeteer: any
}
declare type Partial$1<T> = {
  [P in keyof T]?: T[P];
}
declare type ClusterOptionsArgument = Partial$1<ClusterOptions>
interface TaskFunctionArguments<JobData> {
  page: Page
  data: JobData
  worker: {
    id: number
  }
}
declare type TaskFunction<JobData, ReturnData> = (arg: TaskFunctionArguments<JobData>) => Promise<ReturnData>
// hacky solution to get around Cluster.d.ts private fields
declare class Cluster<JobData = any, ReturnData = any> extends EventEmitter {
  static CONCURRENCY_PAGE: number
  static CONCURRENCY_CONTEXT: number
  static CONCURRENCY_BROWSER: number
  public options
  public perBrowserOptions
  public workers
  public workersAvail
  public workersBusy
  public workersStarting
  public allTargetCount
  public jobQueue
  public errorCount
  public taskFunction
  public idleResolvers
  public waitForOneResolvers
  public browser
  public isClosed
  public startTime
  public nextWorkerId
  public monitoringInterval
  public display
  public duplicateCheckUrls
  public lastDomainAccesses
  public systemMonitor
  public checkForWorkInterval
  static launch(options: ClusterOptionsArgument): Promise<Cluster<any, any>>
  public constructor()
  public init
  public launchWorker
  task(taskFunction: TaskFunction<JobData, ReturnData>): Promise<void>
  public nextWorkCall
  public workCallTimeout
  public work
  public doWork
  public lastLaunchedWorkerTime
  public allowedToStartWorker
  public isTaskFunction
  public queueJob
  queue(data: JobData, taskFunction?: TaskFunction<JobData, ReturnData>): Promise<void>
  queue(taskFunction: TaskFunction<JobData, ReturnData>): Promise<void>
  execute(data: JobData, taskFunction?: TaskFunction<JobData, ReturnData>): Promise<ReturnData>
  execute(taskFunction: TaskFunction<JobData, ReturnData>): Promise<ReturnData>
  idle(): Promise<void>
  waitForOne(): Promise<JobData>
  close(): Promise<void>
  public monitor
}

declare class WS {
    private wss;
    constructor();
    serve(req: IncomingMessage): void;
    handleUpgrade(request: IncomingMessage, socket: Socket): void;
    /**
       * Publish event and data to all connected clients
       * @param {object} data
       */
    broadcast(data: Record<string, any>): void;
}

/**
 * A route definition is a mapping of a component, and it's URL path (or paths) that it represents.
 *
 * The page component has multiple representations:
 * - static route, whereby the name matches the path (/about.vue -> /about/),
 * - dynamic route where a query is used to generate a set of paths (/posts/:id.vue -> /posts/my-first-post/)
 * - catch-all route where the any missed paths will be caught (/404.vue -> /some-missing-page)
 *
 * Additional meta-data is provided to give more context of how the mapping behaves, such as which layout to use, which
 * asset chunk it belongs to.
 *
 * Different frameworks represent this data differently, this one is based on Nuxt.js
 */
interface RouteDefinition {
    name: string;
    path: string;
    file?: string;
    component?: string;
    componentBaseName?: string;
    chunkName?: string;
    _name?: string;
    layout?: string;
}
/**
 * A normalised route, in the context of unlighthouse, is a mapping between a URL path, it's definition and a unique id.
 */
interface NormalisedRoute {
    id: string;
    path: string;
    url: string;
    $url: $URL;
    definition: RouteDefinition;
    /**
     * A runtime path that the route was discovered from, useful if the route is a 404 and we want to know what directed
     * us to it.
     */
    discoveredFrom?: string;
}
interface ComputedLighthouseReportAudit {
    details?: {
        items?: any[];
    };
    displayValue: string | number;
    score: number;
}
/**
 * An augmented Lighthouse Report type, we add custom types to the base report for specific functionality on the
 * @unlighthouse/client.
 */
type LighthouseReport = Partial<LH.Result> & {
    /**
     * The total score for the result, this is the sum of each category's result
     */
    score: number;
    categories: {
        score: number | null;
    }[];
    computed: {
        /**
         * An aggregation of multiple image audit results.
         */
        imageIssues: ComputedLighthouseReportAudit;
        ariaIssues: ComputedLighthouseReportAudit;
    };
};
/**
 * Tasks that Unlighthouse will run, used to track their status.
 */
type UnlighthouseTask = 'inspectHtmlTask' | 'runLighthouseTask';
/**
 * Each task ran by unlighthouse (extractHtmlPayload, runLighthouseTask) has a specific status which we can expose.
 */
type UnlighthouseTaskStatus = 'waiting' | 'in-progress' | 'completed' | 'failed' | 'ignore';
/**
 * A fairly rigid representation of the puppeteer cluster task results (extractHtmlPayload, runLighthouseTask), combined
 * with the normalised route.
 */
interface UnlighthouseRouteReport {
    /**
     * The mapping of tasks with their status.
     */
    tasks: Record<UnlighthouseTask, UnlighthouseTaskStatus>;
    /**
     * Path to where the artifacts from a URL scan are saved.
     */
    artifactPath: string;
    /**
     * URL of where the artifacts are stored, for static client access.
     */
    artifactUrl: string;
    /**
     * The route (URL Path) that the report belongs to.
     */
    route: NormalisedRoute;
    /**
     * A unique representation of the route, useful for the API layer.
     */
    reportId: string;
    /**
     * The lighthouse result, only set once the task is completed.
     */
    report?: LighthouseReport;
    /**
     * The SEO meta-data, only set once the html payload has been extracted and passed.
     */
    seo?: HTMLExtractPayload;
}
interface HTMLExtractPayload {
    alternativeLangDefault?: string;
    title?: string;
    description?: string;
    internalLinks?: number;
    externalLinks?: number;
    favicon?: string;
    og?: {
        description?: string;
        title?: string;
        image?: string;
    };
}
type WindiResponsiveClasses = 'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl';
type ValidReportTypes = 'jsonSimple' | 'jsonExpanded';
/**
 * A column will generally be either a direct mapping to a lighthouse audit (such as console errors) or a computed mapping to
 * multiple lighthouse audits (such as image issues).
 *
 * It can also exist as a mapping to the SEO meta-data (such as meta description).
 */
interface UnlighthouseColumn {
    /**
     * The column header name.
     */
    label: string;
    /**
     * Display the column header icon as a warning.
     */
    warning?: boolean;
    /**
     * If the user hovers over the label they'll see a tooltip for extra context.
     */
    tooltip?: string;
    /**
     * A component instance which should be used to render the column cells contents.
     */
    component?: () => Promise<unknown>;
    /**
     * The key within the UnlighthouseRouteReport that maps to the column, used for automatic value inferring.
     */
    key?: string;
    /**
     * Column sizing definition, needed for a responsive UI.
     *
     * @default 2
     */
    cols?: number;
    /**
     * Can the column can be sorted?
     *
     * @default false
     */
    sortable?: boolean;
    /**
     * The key within the UnlighthouseRouteReport that is used to sort the column. This will default to the key if not provided.
     */
    sortKey?: string;
    /**
     * Extra classes that should be added to the column.
     */
    classes?: string[];
}
/**
 * All available tab keys.
 */
type LighthouseCategories = 'performance' | 'best-practices' | 'accessibility' | 'seo' | 'pwa';
type UnlighthouseTabs = 'overview' | LighthouseCategories;
/**
 * Unlighthouse's intelligent sampling relies on knowing which URLs map to which files in your project.
 * To achieve this it needs to create its own router with your files to test any URL that comes through.
 */
interface MockRouter {
    match: (path: string) => RouteDefinition | false;
}
interface DiscoveryOptions {
    /**
     * The location of the page files that will be matched to routes.
     * Note: This is for fallback behaviour when the integration doesn't provide a way to gather the route definitions.
     *
     * @default './pages'
     */
    pagesDir: string;
    /**
     * Which file extensions in the pages dir should be considered.
     *
     * Note: This is for fallback behaviour when the integration doesn't provide a way to gather the route definitions.
     *
     * @default ['vue', 'md']
     */
    supportedExtensions: string[];
}
interface ClientOptions {
    /**
     * The columns to show for each lighthouse category.
     */
    columns: Record<UnlighthouseTabs, UnlighthouseColumn[]>;
    /**
     * Which key to use to group the routes.
     */
    groupRoutesKey: string;
}
interface GenerateClientOptions {
    static?: boolean;
}
interface ResolvedUserConfig {
    /**
     * The site that will be scanned.
     */
    site: string;
    /**
     * The path that we'll be performing the scan from, this should be the path to the app that represents the site.
     * Using this path we can auto-discover the provider
     * @default cwd()
     */
    root: string;
    /**
     * Should reports be saved to the local file system and re-used between runs for the scanned site.
     *
     * Note: This makes use of cache-bursting for when the configuration changes, since this may change the report output.
     *
     * @default true
     */
    cache: boolean;
    /**
     * Optional basic auth credentials
     *
     * @default false
     */
    auth: false | {
        username: string;
        password: string;
    };
    /**
     * Cookies to add to HTTP requests.
     *
     * @default false
     */
    cookies: false | {
        name: string;
        value: string;
        [v: string]: string;
    }[];
    /**
     * Extra headers to provide for any HTTP requests.
     *
     * @default false
     */
    extraHeaders: false | Record<string, string>;
    /**
     * Load the configuration from a custom config file.
     * By default, it attempts to load configuration from `unlighthouse.config.ts`.
     *
     * You can set up multiple configuration files for different sites you want to scan.
     * For example:
     * - `staging-unlighthouse.config.ts`
     * - `production-unlighthouse.config.ts`
     */
    configFile?: string;
    /**
     * Where to emit lighthouse reports and the runtime client.
     *
     * @default "./lighthouse/"
     */
    outputPath: string;
    /**
     * Display the loggers' debug messages.
     * @default false
     */
    debug: boolean;
    /**
     * Hooks to run to augment the behaviour of Unlighthouse.
     */
    hooks?: NestedHooks<UnlighthouseHooks>;
    /**
     * The URL path prefix for the client and API to run from.
     * Useful when you want to serve the application from an existing integrations server, you could use /__unlighthouse
     *
     * @default ''
     */
    routerPrefix: string;
    /**
     * The path that the API should be served from.
     *
     * @default /api/
     */
    apiPrefix: string;
    /**
     * Provide a list of URLs that should be used explicitly.
     * Will disable sitemap and crawler.
     *
     * @see https://unlighthouse.dev/guide/url-discovery.html#manually-providing-urls
     * @default []
     */
    urls: string[] | (() => string[]) | (() => Promise<string[]>);
    ci: {
        /**
         * Provide a budget for each page as a numeric total score, or an object mapping the category to the score. Should be
         * a number between 1-100.
         */
        budget: number | Record<Partial<LighthouseCategories>, number>;
        /**
         * Injects the required data into the client files, so it can be hosted statically.
         */
        buildStatic: boolean;
        /**
         * The type of report that will be generated from the results.
         *
         * @default 'jsonSimple'
         **/
        reporter: ValidReportTypes | false;
    };
    /**
     * See https://unlighthouse.dev/guide/client.html
     */
    client: ClientOptions;
    /**
     * See https://unlighthouse.dev/guide/route-definitions.html
     */
    discovery: false | DiscoveryOptions;
    scanner: {
        /**
         * Setup custom mappings for a regex string to a route definition.
         * This is useful when you have a complex site which doesn't use URL path segments
         * to separate pages.
         *
         * @see https://unlighthouse.dev/guide/route-definitions.html#custom-sampling
         * @default {}
         */
        customSampling: Record<string, RouteDefinition>;
        /**
         * When the page HTML is extracted and processed, we look for a x-default link to identify if the page is an i18n
         * copy of another page.
         * If it is, then we skip it because it would be a duplicate scan.
         *
         * @default true
         */
        ignoreI18nPages: boolean;
        /**
         * The maximum number of routes that should be processed.
         * This helps avoid issues when the site requires a specific
         * configuration to be able to run properly
         *
         * @default 200
         */
        maxRoutes: number | false;
        /**
         * Paths to explicitly include from the search, this will exclude any paths not listed here.
         *
         * @see https://unlighthouse.dev/guide/large-sites.html#include-url-patterns
         */
        include?: (string | RegExp)[];
        /**
         * Paths to ignore from scanning.
         *
         * @see https://unlighthouse.dev/guide/large-sites.html#exclude-url-patterns
         */
        exclude?: (string | RegExp)[];
        /**
         * Does javascript need to be executed in order to fetch internal links and SEO data.
         *
         * @see https://unlighthouse.dev/guide/spa.html
         */
        skipJavascript: boolean;
        /**
         * How many samples of each route should be done.
         * This is used to improve false-positive results.
         *
         * @see https://unlighthouse.dev/guide/improving-accuracy.html
         * @default 1
         */
        samples: number;
        /**
         * Should lighthouse run with throttling enabled? This is an alias for manually configuring lighthouse.
         *
         * @see https://unlighthouse.dev/guide/device.html#alias-enable-disable-throttling
         * @default false
         */
        throttle: boolean;
        /**
         * Should the crawler be used to detect URLs.
         *
         * @see https://unlighthouse.dev/guide/crawling.html
         * @default true
         */
        crawler: boolean;
        /**
         * When a route definition is provided, you're able to configure the worker to sample the dynamic routes to avoid
         * redundant route reports.
         *
         * @see https://unlighthouse.dev/guide/large-sites.html#change-dynamic-sampling-limit
         * @default 5
         */
        dynamicSampling: number | false;
        /**
         * Whether the sitemap.xml will be attempted to be read from the site.
         *
         * @default true
         */
        sitemap: boolean | string[];
        /**
         * Whether the robots.txt will be attempted to be read from the site.
         *
         * @default true
         */
        robotsTxt: boolean;
        /**
         * Alias to switch the device used for scanning.
         * Set to false if you want to manually configure it.
         *
         * @default 'mobile'
         */
        device: 'mobile' | 'desktop' | false;
    };
    /**
     * Changes the default behaviour of lighthouse.
     */
    lighthouseOptions: LH.Flags;
    /**
     * Change the behaviour of puppeteer.
     */
    puppeteerOptions: PuppeteerNodeLaunchOptions;
    /**
     * Change the behaviour of puppeteer-cluster.
     */
    puppeteerClusterOptions: Partial<{
        concurrency: number | unknown;
        maxConcurrency: number;
        workerCreationDelay: number;
        puppeteerOptions: LaunchOptions$1;
        perBrowserOptions: LaunchOptions$1[] | undefined;
        monitor: boolean;
        timeout: number;
        retryLimit: number;
        retryDelay: number;
        skipDuplicateUrls: boolean;
        sameDomainDelay: number;
        puppeteer: any;
    }>;
    chrome: {
        /**
         * Should chrome be attempted to be used from the system.
         *
         * @default true
         */
        useSystem: boolean;
        /**
         * If no chrome can be found in the system, should a download fallback be attempted.
         *
         * @default true
         */
        useDownloadFallback: boolean;
        /**
         * When downloading the fallback which version of chrome should be used.
         *
         * @default 1095492
         */
        downloadFallbackVersion: string | number;
        /**
         * The directory to install the downloaded fallback browser.
         *
         * @default $home/.unlighthouse
         */
        downloadFallbackCacheDir: string;
    };
}
type ClientOptionsPayload = Pick<ResolvedUserConfig, 'client' | 'site' | 'lighthouseOptions' | 'scanner' | 'routerPrefix'> & Pick<RuntimeSettings, 'websocketUrl' | 'apiUrl'>;
type DeepPartial<T> = T extends Function ? T : (T extends object ? {
    [P in keyof T]?: DeepPartial<T[P]>;
} : T);
type UserConfig = DeepPartial<ResolvedUserConfig>;
interface RuntimeSettings {
    /**
     * A URL instance of the site for easier use of the host.
     */
    siteUrl: $URL;
    /**
     * The URL of the server running the API and client.
     */
    serverUrl: string;
    /**
     * The full URL for API.
     */
    apiUrl: string;
    /**
     * The path of the api without the site URL.
     */
    apiPath: string;
    /**
     * Whether we have managed to resolve definitions for the routes.
     */
    hasRouteDefinitions: boolean;
    /**
     * if the user has configured unlighthouse using a configuration file, this is the link to it.
     */
    configFile?: string;
    /**
     * When caching we need to generate a unique key based on config.
     */
    configCacheKey?: string;
    /**
     * The URL that the websocket will be served from, depends on the api.prefix. Will look something like:
     * "ws://localhost:3000/ws".
     */
    websocketUrl: string;
    /**
     * The resolved local path to the generated client.
     */
    generatedClientPath: string;
    /**
     * The URL to the client, used for opening it automatically.
     */
    clientUrl: string;
    /**
     * The resolved local path to the client dist.
     */
    resolvedClientPath: string;
    /**
     * The resolved output path we'll be saving reports and the client in.
     */
    outputPath: string;
    /**
     * The root directory of the module.
     */
    moduleWorkingDir: string;
    /**
     * The path to the lighthouse worker.
     */
    lighthouseProcessPath: string;
    /**
     * The server instance.
     */
    server: http.Server | https.Server;
}
interface UnlighthouseWorkerStats {
    /**
     * Status of the worker, completed when all tasks have been completed.
     */
    status: 'completed' | 'working';
    /**
     * Time in ms that the worker has been running
     */
    timeRunning: number;
    /**
     * How many tasks have been completed.
     */
    doneTargets: number;
    /**
     * Total number of tasks including completed, pending and working.
     */
    allTargets: number;
    /**
     * The % of work completed.
     */
    donePercStr: string;
    /**
     * The % of errors.
     */
    errorPerc: string;
    /**
     * The remaining time until all tasks are completed.
     */
    timeRemaining: number;
    /**
     * How many tasks per second are being processed.
     */
    pagesPerSecond: string;
    /**
     * The devices CPU usage % out of 100
     */
    cpuUsage: string;
    /**
     * The devices memory usage % out of 100
     */
    memoryUsage: string;
    /**
     * How many workers are now working, usually the cpu count of the device.
     */
    workers: number;
}
type PuppeteerTaskArgs = UnlighthouseRouteReport;
type PuppeteerTaskReturn = UnlighthouseRouteReport;
type PuppeteerTask = TaskFunction<PuppeteerTaskArgs, PuppeteerTaskReturn>;
type UnlighthousePuppeteerCluster = Cluster<PuppeteerTaskArgs, PuppeteerTaskReturn>;
/**
 * A provider is an integration of unlighthouse to a specific context, such as a framework or an environment.
 *
 * Each provider has their own unique name and defines how they will provide URLs and route definitions to unlighthouse.
 */
interface Provider {
    /**
     * Used to debug.
     */
    name?: string;
    /**
     * To match a URL path to a route definition we need a router. Different definitions need different routes.
     */
    mockRouter?: MockRouter | ((routeDefinitions: RouteDefinition[]) => MockRouter);
    /**
     * The collection of route definitions belonging to the provider. These can be inferred but aren't 100% correct,
     * frameworks that can provide these should do so.
     */
    routeDefinitions?: RouteDefinition[] | (() => RouteDefinition[] | Promise<RouteDefinition[]>);
}
type HookResult = Promise<void> | void;
interface UnlighthouseHooks {
    /**
     * It's possible the site is not known at initialisation, this hook is called when it's set or changed.
     * @param site The site that was set.
     */
    'site-changed': (site: string) => HookResult;
    /**
     * Once the config is resolved.
     *
     * @param resolvedConfig
     */
    'resolved-config': (resolvedConfig: ResolvedUserConfig) => HookResult;
    /**
     * Called when the worker has finished processing all queued routes. Will be called multiple times if routes are
     * re-queued.
     *
     * Mostly useful for the CI environment.
     */
    'worker-finished': () => HookResult;
    /**
     * When route definitions are provided to Unlighthouse this function will be called, useful for delaying internal logic
     * until the definitions are found.
     *
     * @param routeDefinitions
     */
    'route-definitions-provided': (routeDefinitions: any[]) => HookResult;
    /**
     * Called when a user visits the path of the @unlighthouse/client for the first time. Useful for starting the worker on-demand.
     */
    'visited-client': () => HookResult;
    /**
     * Fired when a new task is added to the queue worker.
     * @param path
     * @param response
     */
    'task-added': (path: string, response: UnlighthouseRouteReport) => HookResult;
    /**
     * Fired when a task has started to work.
     * @param path
     * @param response
     */
    'task-started': (path: string, response: UnlighthouseRouteReport) => HookResult;
    /**
     * Fired when a task has completed it's work.
     * @param path
     * @param response
     */
    'task-complete': (path: string, response: UnlighthouseRouteReport, taskName: string) => HookResult;
    /**
     * Fired when a path discovered internal links, used for "crawl" mode.
     * @param path
     * @param internalLinks
     */
    'discovered-internal-links': (path: string, internalLinks: string[]) => HookResult;
    /**
     * After a page has been visited with puppeteer. Useful for running
     * @param page
     */
    'puppeteer:before-goto': (page: Page$1) => HookResult;
}
/**
 * The worker is the manager of puppeteer-cluster, it provides an API for managing the queued routes, monitoring the queue and
 * fetching the results of the queued jobs.
 */
interface UnlighthouseWorker {
    /**
     * puppeteer-cluster instance
     */
    cluster: Cluster;
    /**
     * A collection of stats gathered from the cluster for the current status of the worker.
     */
    monitor: () => UnlighthouseWorkerStats;
    /**
     * Queue a single normalised route. Will not process routes that have already been queued.
     * @param route
     */
    queueRoute: (route: NormalisedRoute) => void;
    /**
     * Queue multiple normalised routes. This will sort the list for a better loading experience.
     * @param routes
     */
    queueRoutes: (routes: NormalisedRoute[]) => void;
    /**
     * Re-queues a report, avoiding the usual caching involved and makes sure we unlink any of the previous reports data or
     * tasks.
     *
     * @param report
     */
    requeueReport: (report: UnlighthouseRouteReport) => void;
    /**
     * Has the worker started processing the queue.
     */
    hasStarted: () => boolean;
    /**
     * The gathered map of reports. The key is the path of the route.
     */
    routeReports: Map<string, UnlighthouseRouteReport>;
    /**
     * A simple array representation of the reports for easy iteration.
     */
    reports: () => UnlighthouseRouteReport[];
    /**
     * Find a report with the specified id.
     * @param id
     */
    findReport: (id: string) => UnlighthouseRouteReport | null;
    /**
     * Iterates through route reports checking for a match on the route definition component, if there is a match
     * then the route is re-queued.
     *
     * @param file
     * @return True if an invalidation occurred on the routes.
     */
    invalidateFile: (file: string) => boolean;
    /**
     * Checks if the amount of routes scanned surpasses the `scanner.maxRoutes` value.
     */
    exceededMaxRoutes: () => boolean;
}
interface ScanMeta {
    /**
     * Total count of discovered routes
     */
    routes: number;
    /**
     * How are worker is operating
     */
    monitor?: UnlighthouseWorkerStats;
    /**
     * Aggregate score for the site
     */
    score: number;
    /**
     * Discovered site favicon.
     */
    favicon?: string;
}
interface ServerContextArg {
    url: string;
    server: http.Server | https.Server;
    app: App;
}
/**
 * The context is provided by the createUnlighthouse() or useUnlighthouse() functions.
 * It provides the central API to interact with the behaviour of Unlighthouse..
 */
interface UnlighthouseContext {
    /**
     * The mock router being used to match paths to route definitions.
     */
    mockRouter?: MockRouter;
    /**
     * Settings that are computed from runtime data.
     */
    runtimeSettings: RuntimeSettings;
    /**
     * Access the hook system, either calling a hook or listening to one.
     */
    hooks: Hookable<UnlighthouseHooks>;
    /**
     * User config that has been normalised.
     */
    resolvedConfig: ResolvedUserConfig;
    /**
     * The collection of route definitions associated to the site.
     */
    routeDefinitions?: RouteDefinition[];
    /**
     * Discovered routes.
     */
    routes?: NormalisedRoute[];
    /**
     * A reference to the API middleware.
     */
    api: any;
    /**
     * A reference to the websocket interface, used to broadcast data.
     */
    ws: WS;
    /**
     * Access the worker environment, queue tasks, inspect progress, etc.
     */
    worker: UnlighthouseWorker;
    /**
     * Provider details
     */
    provider: Provider;
    /**
     * To use Unlighthouse with a client, it needs a server / app to register the API and client middleware.
     *
     * @param arg
     */
    setServerContext: (arg: ServerContextArg) => Promise<UnlighthouseContext>;
    /**
     * Sets the site URL that will be scanned if it's not known at initialisation.
     * @param url
     */
    setSiteUrl: (url: string) => void;
    /**
     * Running Unlighthouse via CI does not require a server or the client so we have a special utility for it.
     */
    setCiContext: () => Promise<UnlighthouseContext>;
    /**
     * Start the client and the queue worker. A server context must be provided before this function is called.
     */
    start: () => Promise<UnlighthouseContext>;
}

declare const ReportArtifacts: {
    html: string;
    reportHtml: string;
    screenshot: string;
    fullScreenScreenshot: string;
    screenshotThumbnailsDir: string;
    reportJson: string;
};
/**
 * Ensures a provided host is consistent, ensuring a protocol is provided.
 *
 * @param host
 */
declare function normaliseHost(host: string): string;
declare function fetchUrlRaw(url: string, resolvedConfig: ResolvedUserConfig): Promise<{
    error?: any;
    redirected?: boolean;
    redirectUrl?: string;
    valid: boolean;
    response?: AxiosResponse;
}>;

/**
 * Gets the instantiated logger instance using the shared context, persists the application logging configuration.
 */
declare const useLogger: () => ConsolaInstance;

/**
 * Use the unlighthouse instance.
 */
declare const useUnlighthouse: () => UnlighthouseContext;
/**
 * A simple define wrapper to provide typings to config definitions.
 * @param config
 */
declare function defineConfig(config: UserConfig): {
    site?: string | undefined;
    root?: string | undefined;
    cache?: boolean | undefined;
    auth?: false | {
        username?: string | undefined;
        password?: string | undefined;
    } | undefined;
    cookies?: false | ({
        [x: string]: string | undefined;
        name?: string | undefined;
        value?: string | undefined;
    } | undefined)[] | undefined;
    extraHeaders?: false | {
        [x: string]: string | undefined;
    } | undefined;
    configFile?: string | undefined;
    outputPath?: string | undefined;
    debug?: boolean | undefined;
    hooks?: {
        'site-changed'?: ((site: string) => HookResult) | undefined;
        'resolved-config'?: ((resolvedConfig: ResolvedUserConfig) => HookResult) | undefined;
        'worker-finished'?: (() => HookResult) | undefined;
        'route-definitions-provided'?: ((routeDefinitions: any[]) => HookResult) | undefined;
        'visited-client'?: (() => HookResult) | undefined;
        'task-added'?: ((path: string, response: UnlighthouseRouteReport) => HookResult) | undefined;
        'task-started'?: ((path: string, response: UnlighthouseRouteReport) => HookResult) | undefined;
        'task-complete'?: ((path: string, response: UnlighthouseRouteReport, taskName: string) => HookResult) | undefined;
        'discovered-internal-links'?: ((path: string, internalLinks: string[]) => HookResult) | undefined;
        'puppeteer:before-goto'?: ((page: puppeteer_core.Page) => HookResult) | undefined;
        puppeteer?: {
            "before-goto"?: ((page: puppeteer_core.Page) => HookResult) | undefined;
        } | {
            "before-goto"?: ((page: puppeteer_core.Page) => HookResult) | undefined;
        } | undefined;
    } | {
        puppeteer?: {
            "before-goto"?: ((page: puppeteer_core.Page) => HookResult) | undefined;
        } | {
            "before-goto"?: ((page: puppeteer_core.Page) => HookResult) | undefined;
        } | undefined;
        "site-changed"?: ((site: string) => HookResult) | undefined;
        "resolved-config"?: ((resolvedConfig: ResolvedUserConfig) => HookResult) | undefined;
        "worker-finished"?: (() => HookResult) | undefined;
        "route-definitions-provided"?: ((routeDefinitions: any[]) => HookResult) | undefined;
        "visited-client"?: (() => HookResult) | undefined;
        "task-added"?: ((path: string, response: UnlighthouseRouteReport) => HookResult) | undefined;
        "task-started"?: ((path: string, response: UnlighthouseRouteReport) => HookResult) | undefined;
        "task-complete"?: ((path: string, response: UnlighthouseRouteReport, taskName: string) => HookResult) | undefined;
        "discovered-internal-links"?: ((path: string, internalLinks: string[]) => HookResult) | undefined;
    } | undefined;
    routerPrefix?: string | undefined;
    apiPrefix?: string | undefined;
    urls?: (string | undefined)[] | (() => string[]) | (() => Promise<string[]>) | undefined;
    ci?: {
        budget?: number | {
            seo?: number | undefined;
            performance?: number | undefined;
            "best-practices"?: number | undefined;
            accessibility?: number | undefined;
            pwa?: number | undefined;
        } | undefined;
        buildStatic?: boolean | undefined;
        reporter?: false | ValidReportTypes | undefined;
    } | undefined;
    client?: {
        columns?: {
            seo?: ({
                label?: string | undefined;
                warning?: boolean | undefined;
                tooltip?: string | undefined;
                component?: (() => Promise<unknown>) | undefined;
                key?: string | undefined;
                cols?: number | undefined;
                sortable?: boolean | undefined;
                sortKey?: string | undefined;
                classes?: (string | undefined)[] | undefined;
            } | undefined)[] | undefined;
            performance?: ({
                label?: string | undefined;
                warning?: boolean | undefined;
                tooltip?: string | undefined;
                component?: (() => Promise<unknown>) | undefined;
                key?: string | undefined;
                cols?: number | undefined;
                sortable?: boolean | undefined;
                sortKey?: string | undefined;
                classes?: (string | undefined)[] | undefined;
            } | undefined)[] | undefined;
            overview?: ({
                label?: string | undefined;
                warning?: boolean | undefined;
                tooltip?: string | undefined;
                component?: (() => Promise<unknown>) | undefined;
                key?: string | undefined;
                cols?: number | undefined;
                sortable?: boolean | undefined;
                sortKey?: string | undefined;
                classes?: (string | undefined)[] | undefined;
            } | undefined)[] | undefined;
            "best-practices"?: ({
                label?: string | undefined;
                warning?: boolean | undefined;
                tooltip?: string | undefined;
                component?: (() => Promise<unknown>) | undefined;
                key?: string | undefined;
                cols?: number | undefined;
                sortable?: boolean | undefined;
                sortKey?: string | undefined;
                classes?: (string | undefined)[] | undefined;
            } | undefined)[] | undefined;
            accessibility?: ({
                label?: string | undefined;
                warning?: boolean | undefined;
                tooltip?: string | undefined;
                component?: (() => Promise<unknown>) | undefined;
                key?: string | undefined;
                cols?: number | undefined;
                sortable?: boolean | undefined;
                sortKey?: string | undefined;
                classes?: (string | undefined)[] | undefined;
            } | undefined)[] | undefined;
            pwa?: ({
                label?: string | undefined;
                warning?: boolean | undefined;
                tooltip?: string | undefined;
                component?: (() => Promise<unknown>) | undefined;
                key?: string | undefined;
                cols?: number | undefined;
                sortable?: boolean | undefined;
                sortKey?: string | undefined;
                classes?: (string | undefined)[] | undefined;
            } | undefined)[] | undefined;
        } | undefined;
        groupRoutesKey?: string | undefined;
    } | undefined;
    discovery?: false | {
        pagesDir?: string | undefined;
        supportedExtensions?: (string | undefined)[] | undefined;
    } | undefined;
    scanner?: {
        customSampling?: {
            [x: string]: {
                name?: string | undefined;
                path?: string | undefined;
                file?: string | undefined;
                component?: string | undefined;
                componentBaseName?: string | undefined;
                chunkName?: string | undefined;
                _name?: string | undefined;
                layout?: string | undefined;
            } | undefined;
        } | undefined;
        ignoreI18nPages?: boolean | undefined;
        maxRoutes?: number | false | undefined;
        include?: (string | {
            exec?: ((string: string) => RegExpExecArray | null) | undefined;
            test?: ((string: string) => boolean) | undefined;
            readonly source?: string | undefined;
            readonly global?: boolean | undefined;
            readonly ignoreCase?: boolean | undefined;
            readonly multiline?: boolean | undefined;
            lastIndex?: number | undefined;
            compile?: ((pattern: string, flags?: string | undefined) => RegExp) | undefined;
            readonly flags?: string | undefined;
            readonly sticky?: boolean | undefined;
            readonly unicode?: boolean | undefined;
            readonly dotAll?: boolean | undefined;
            readonly hasIndices?: boolean | undefined;
            [Symbol.match]?: ((string: string) => RegExpMatchArray | null) | undefined;
            [Symbol.replace]?: {
                (string: string, replaceValue: string): string;
                (string: string, replacer: (substring: string, ...args: any[]) => string): string;
            } | undefined;
            [Symbol.search]?: ((string: string) => number) | undefined;
            [Symbol.split]?: ((string: string, limit?: number | undefined) => string[]) | undefined;
            [Symbol.matchAll]?: ((str: string) => IterableIterator<RegExpMatchArray>) | undefined;
        } | undefined)[] | undefined;
        exclude?: (string | {
            exec?: ((string: string) => RegExpExecArray | null) | undefined;
            test?: ((string: string) => boolean) | undefined;
            readonly source?: string | undefined;
            readonly global?: boolean | undefined;
            readonly ignoreCase?: boolean | undefined;
            readonly multiline?: boolean | undefined;
            lastIndex?: number | undefined;
            compile?: ((pattern: string, flags?: string | undefined) => RegExp) | undefined;
            readonly flags?: string | undefined;
            readonly sticky?: boolean | undefined;
            readonly unicode?: boolean | undefined;
            readonly dotAll?: boolean | undefined;
            readonly hasIndices?: boolean | undefined;
            [Symbol.match]?: ((string: string) => RegExpMatchArray | null) | undefined;
            [Symbol.replace]?: {
                (string: string, replaceValue: string): string;
                (string: string, replacer: (substring: string, ...args: any[]) => string): string;
            } | undefined;
            [Symbol.search]?: ((string: string) => number) | undefined;
            [Symbol.split]?: ((string: string, limit?: number | undefined) => string[]) | undefined;
            [Symbol.matchAll]?: ((str: string) => IterableIterator<RegExpMatchArray>) | undefined;
        } | undefined)[] | undefined;
        skipJavascript?: boolean | undefined;
        samples?: number | undefined;
        throttle?: boolean | undefined;
        crawler?: boolean | undefined;
        dynamicSampling?: number | false | undefined;
        sitemap?: boolean | (string | undefined)[] | undefined;
        robotsTxt?: boolean | undefined;
        device?: false | "mobile" | "desktop" | undefined;
    } | undefined;
    lighthouseOptions?: {
        port?: number | undefined;
        hostname?: string | undefined;
        logLevel?: "silent" | "error" | "info" | "verbose" | undefined;
        configPath?: string | undefined;
        plugins?: (string | undefined)[] | undefined;
        output?: lighthouse.LH.OutputMode | (lighthouse.LH.OutputMode | undefined)[] | undefined;
        locale?: lighthouse.LH.Locale | undefined;
        maxWaitForFcp?: number | undefined;
        maxWaitForLoad?: number | undefined;
        blockedUrlPatterns?: (string | undefined)[] | null | undefined;
        additionalTraceCategories?: string | null | undefined;
        auditMode?: string | boolean | undefined;
        gatherMode?: string | boolean | undefined;
        disableStorageReset?: boolean | undefined;
        formFactor?: "mobile" | "desktop" | undefined;
        screenEmulation?: {
            width?: number | undefined;
            height?: number | undefined;
            deviceScaleFactor?: number | undefined;
            mobile?: boolean | undefined;
            disabled?: boolean | undefined;
        } | undefined;
        emulatedUserAgent?: string | boolean | undefined;
        throttlingMethod?: "devtools" | "simulate" | "provided" | undefined;
        throttling?: {
            rttMs?: number | undefined;
            throughputKbps?: number | undefined;
            requestLatencyMs?: number | undefined;
            downloadThroughputKbps?: number | undefined;
            uploadThroughputKbps?: number | undefined;
            cpuSlowdownMultiplier?: number | undefined;
        } | undefined;
        onlyAudits?: (string | undefined)[] | null | undefined;
        onlyCategories?: (string | undefined)[] | null | undefined;
        skipAudits?: (string | undefined)[] | null | undefined;
        channel?: string | undefined;
        precomputedLanternData?: {
            additionalRttByOrigin?: {
                [x: string]: number | undefined;
            } | undefined;
            serverResponseTimeByOrigin?: {
                [x: string]: number | undefined;
            } | undefined;
        } | null | undefined;
        budgets?: any[] | null | undefined;
        extraHeaders?: {
            [x: string]: string | undefined;
        } | undefined;
    } | undefined;
    puppeteerOptions?: {
        headless?: boolean | "new" | undefined;
        userDataDir?: string | undefined;
        devtools?: boolean | undefined;
        debuggingPort?: number | undefined;
        args?: (string | undefined)[] | undefined;
        channel?: puppeteer.ChromeReleaseChannel | undefined;
        executablePath?: string | undefined;
        ignoreDefaultArgs?: boolean | (string | undefined)[] | undefined;
        handleSIGINT?: boolean | undefined;
        handleSIGTERM?: boolean | undefined;
        handleSIGHUP?: boolean | undefined;
        timeout?: number | undefined;
        dumpio?: boolean | undefined;
        env?: {
            [x: string]: string | undefined;
        } | undefined;
        pipe?: boolean | undefined;
        product?: puppeteer.Product | undefined;
        extraPrefsFirefox?: {
            [x: string]: unknown;
        } | undefined;
        waitForInitialPage?: boolean | undefined;
        ignoreHTTPSErrors?: boolean | undefined;
        defaultViewport?: {
            width?: number | undefined;
            height?: number | undefined;
            deviceScaleFactor?: number | undefined;
            isMobile?: boolean | undefined;
            isLandscape?: boolean | undefined;
            hasTouch?: boolean | undefined;
        } | null | undefined;
        slowMo?: number | undefined;
        targetFilter?: puppeteer.TargetFilterCallback | undefined;
        protocolTimeout?: number | undefined;
    } | undefined;
    puppeteerClusterOptions?: {
        concurrency?: unknown;
        maxConcurrency?: number | undefined;
        workerCreationDelay?: number | undefined;
        puppeteerOptions?: {
            channel?: puppeteer_core.ChromeReleaseChannel | undefined;
            executablePath?: string | undefined;
            ignoreDefaultArgs?: boolean | (string | undefined)[] | undefined;
            handleSIGINT?: boolean | undefined;
            handleSIGTERM?: boolean | undefined;
            handleSIGHUP?: boolean | undefined;
            timeout?: number | undefined;
            dumpio?: boolean | undefined;
            env?: {
                [x: string]: string | undefined;
            } | undefined;
            pipe?: boolean | undefined;
            product?: puppeteer_core.Product | undefined;
            extraPrefsFirefox?: {
                [x: string]: unknown;
            } | undefined;
            waitForInitialPage?: boolean | undefined;
        } | undefined;
        perBrowserOptions?: ({
            channel?: puppeteer_core.ChromeReleaseChannel | undefined;
            executablePath?: string | undefined;
            ignoreDefaultArgs?: boolean | (string | undefined)[] | undefined;
            handleSIGINT?: boolean | undefined;
            handleSIGTERM?: boolean | undefined;
            handleSIGHUP?: boolean | undefined;
            timeout?: number | undefined;
            dumpio?: boolean | undefined;
            env?: {
                [x: string]: string | undefined;
            } | undefined;
            pipe?: boolean | undefined;
            product?: puppeteer_core.Product | undefined;
            extraPrefsFirefox?: {
                [x: string]: unknown;
            } | undefined;
            waitForInitialPage?: boolean | undefined;
        } | undefined)[] | undefined;
        monitor?: boolean | undefined;
        timeout?: number | undefined;
        retryLimit?: number | undefined;
        retryDelay?: number | undefined;
        skipDuplicateUrls?: boolean | undefined;
        sameDomainDelay?: number | undefined;
        puppeteer?: any;
    } | undefined;
    chrome?: {
        useSystem?: boolean | undefined;
        useDownloadFallback?: boolean | undefined;
        downloadFallbackVersion?: string | number | undefined;
        downloadFallbackCacheDir?: string | undefined;
    } | undefined;
};
/**
 * Create a unique single unlighthouse instance that can be referenced globally with `useUnlighthouse()`. Scanning will
 * not start automatically, a server context needs to be provided using `setServerContext()`.
 *
 * @param userConfig
 * @param provider
 */
declare function createUnlighthouse(userConfig: UserConfig, provider?: Provider): Promise<UnlighthouseContext>;

/**
 * Copies the file contents of the @unlighthouse/client package and does transformation based on the provided configuration.
 *
 * The main transformation is injecting the unlighthouse configuration into the head of the document, making it accessible
 * to the client.
 *
 * An additional transforming is needed to modify the vite base URL which is a bit more involved.
 */
declare function generateClient(options?: GenerateClientOptions, unlighthouse?: UnlighthouseContext): Promise<void>;

export { ClientOptions, ClientOptionsPayload, ComputedLighthouseReportAudit, DeepPartial, DiscoveryOptions, GenerateClientOptions, HTMLExtractPayload, HookResult, LighthouseCategories, LighthouseReport, MockRouter, NormalisedRoute, Provider, PuppeteerTask, PuppeteerTaskArgs, PuppeteerTaskReturn, ReportArtifacts, ResolvedUserConfig, RouteDefinition, RuntimeSettings, ScanMeta, ServerContextArg, UnlighthouseColumn, UnlighthouseContext, UnlighthouseHooks, UnlighthousePuppeteerCluster, UnlighthouseRouteReport, UnlighthouseTabs, UnlighthouseTask, UnlighthouseTaskStatus, UnlighthouseWorker, UnlighthouseWorkerStats, UserConfig, ValidReportTypes, WindiResponsiveClasses, createUnlighthouse, defineConfig, fetchUrlRaw, generateClient, normaliseHost, useLogger, useUnlighthouse };
