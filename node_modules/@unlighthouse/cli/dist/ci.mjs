import fse from 'fs-extra';
import { createUnlighthouse, useUnlighthouse, useLogger, generateClient } from '@unlighthouse/core';
import { relative } from 'pathe';
import { isCI } from 'std-env';
import { h as handleError, c as createCli, p as pickOptions, v as validateHost, a as validateOptions } from './shared/cli.ecaed16a.mjs';
import { join } from 'node:path';
import 'node:url';
import 'lodash-es';
import 'defu';
import 'consola';
import 'cac';

function reportJsonSimple(reports) {
  return reports.map((report) => {
    return {
      path: report.route.path,
      score: report.report?.score
    };
  }).sort((a, b) => a.path.localeCompare(b.path));
}

const relevantMetrics = [
  "largest-contentful-paint",
  "cumulative-layout-shift",
  "first-contentful-paint",
  "total-blocking-time",
  "max-potential-fid",
  "interactive"
];
function reportJsonExpanded(unlighthouseRouteReports) {
  let metadata = {
    metrics: {},
    categories: {}
  };
  const routes = unlighthouseRouteReports.map((report) => {
    const categories = Object.values(report.report?.categories ?? {}).reduce(
      (prev, category) => {
        metadata = {
          ...metadata,
          categories: {
            ...metadata.categories,
            [category.key]: {
              id: category.id,
              title: category.title
            }
          }
        };
        return {
          ...prev,
          [category.key]: {
            score: category.score
          }
        };
      },
      {}
    );
    const metrics = Object.values(report.report?.audits ?? {}).filter((metric) => relevantMetrics.includes(metric.id)).reduce((prev, metric) => {
      metadata = {
        ...metadata,
        metrics: {
          ...metadata.metrics,
          [metric.id]: {
            id: metric.id,
            title: metric.title,
            description: metric.description,
            numericUnit: metric.numericUnit
          }
        }
      };
      return {
        ...prev,
        [metric.id]: {
          numericValue: metric.numericValue,
          displayValue: metric.displayValue
        }
      };
    }, {});
    return {
      path: report.route.path,
      score: report.report?.score,
      categories,
      metrics
    };
  }).sort((a, b) => a.path.localeCompare(b.path));
  const averageCategories = extractCategoriesFromRoutes(routes);
  const averageMetrics = extractMetricsFromRoutes(routes);
  const summary = {
    score: parseFloat(
      (routes.reduce((prev, curr) => prev + curr.score, 0) / routes.length).toFixed(2)
    ),
    categories: averageCategories,
    metrics: averageMetrics
  };
  return {
    summary,
    routes,
    metadata
  };
}
function extractCategoriesFromRoutes(routes) {
  const categoriesWithAllScores = routes.reduce((prev, curr) => {
    return Object.keys(curr.categories).reduce((target, categoryKey) => {
      const scores = target[categoryKey] ? target[categoryKey].scores : [];
      const { score, ...strippedCategory } = curr.categories[categoryKey];
      return {
        ...target,
        [categoryKey]: {
          ...strippedCategory,
          scores: [...scores, curr.categories[categoryKey].score]
        }
      };
    }, prev);
  }, {});
  return Object.keys(categoriesWithAllScores).reduce(
    (prev, key) => {
      const averageScore = parseFloat(
        (categoriesWithAllScores[key].scores.reduce(
          (prev2, curr) => prev2 + curr,
          0
        ) / categoriesWithAllScores[key].scores.length).toFixed(2)
      );
      const { scores, ...strippedCategory } = categoriesWithAllScores[key];
      return { ...prev, [key]: { ...strippedCategory, averageScore } };
    },
    {}
  );
}
function extractMetricsFromRoutes(routes) {
  const metricsWithAllNumericValues = routes.reduce((prev, curr) => {
    return Object.keys(curr.metrics).reduce((target, metricKey) => {
      const numericValues = target[metricKey] ? target[metricKey].numericValues : [];
      const { numericValue, displayValue, ...strippedMetric } = curr.metrics[metricKey];
      return {
        ...target,
        [metricKey]: {
          ...strippedMetric,
          numericValues: [...numericValues, curr.metrics[metricKey].numericValue]
        }
      };
    }, prev);
  }, {});
  return Object.keys(metricsWithAllNumericValues).reduce(
    (prev, key) => {
      const averageNumericValue = parseFloat(
        (metricsWithAllNumericValues[key].numericValues.reduce(
          (prev2, curr) => prev2 + curr,
          0
        ) / metricsWithAllNumericValues[key].numericValues.length).toFixed(2)
      );
      const { numericValues, ...strippedMetric } = metricsWithAllNumericValues[key];
      return { ...prev, [key]: { ...strippedMetric, averageNumericValue } };
    },
    {}
  );
}

function generateReportPayload(reporter, reports) {
  if (reporter.startsWith("json"))
    return reporter === "jsonSimple" ? reportJsonSimple(reports) : reportJsonExpanded(reports);
  throw new Error(`Unsupported reporter: ${reporter}.`);
}
async function outputReport(reporter, config, payload) {
  if (reporter.startsWith("json")) {
    const path = join(config.root, config.outputPath, "ci-result.json");
    await fse.writeJson(path, payload, { spaces: 2 });
    return path;
  }
  throw new Error(`Unsupported reporter: ${reporter}.`);
}

async function run() {
  const startTime = /* @__PURE__ */ new Date();
  const cli = createCli();
  cli.option("--budget <budget>", "Budget (1-100), the minimum score which can pass.");
  cli.option("--build-static <build-static>", "Build a static website for the reports which can be uploaded.");
  cli.option("--reporter <reporter>", "The report to generate from results. Options: jsonSimple, jsonExpanded or false. Default is jsonSimple.");
  const { options } = cli.parse();
  if (options.help || options.version)
    return;
  const resolvedOptions = pickOptions(options);
  resolvedOptions.ci = {
    budget: options.budget || void 0,
    buildStatic: options.buildStatic || false,
    reporter: options.reporter || "jsonSimple"
  };
  await createUnlighthouse(
    {
      ...resolvedOptions,
      hooks: {
        "resolved-config": async (config) => {
          await validateHost(config);
        }
      },
      cache: false
    },
    { name: "ci" }
  );
  const { resolvedConfig, setCiContext, hooks, worker, start } = useUnlighthouse();
  validateOptions(resolvedConfig);
  const logger = useLogger();
  let hasBudget = true;
  if (!resolvedConfig.ci?.budget) {
    hasBudget = false;
    logger.warn("Warn: No CI budget has been set. Consider setting a budget with the config (`ci.budget`) or --budget <number>.");
  }
  await setCiContext();
  await start();
  hooks.hook("worker-finished", async () => {
    const end = /* @__PURE__ */ new Date();
    const seconds = Math.round((end.getTime() - startTime.getTime()) / 1e3);
    logger.success(`Unlighthouse has finished scanning \`${resolvedConfig.site}\`: ${worker.reports().length} routes in \`${seconds}s\`.`);
    let hadError = false;
    if (hasBudget) {
      logger.info("Running score budgets.", resolvedConfig.ci.budget);
      worker.reports().forEach((report) => {
        const categories = report.report?.categories;
        if (!categories)
          return;
        Object.values(categories).forEach((category) => {
          let budget = resolvedConfig.ci.budget;
          if (!Number.isInteger(budget))
            budget = resolvedConfig.ci.budget[category.key];
          if (category.score && category.score * 100 < budget) {
            logger.error(
              `${report.route.path} has invalid score \`${category.score}\` for category \`${category.key}\`.`
            );
            hadError = true;
          }
        });
      });
      if (!hadError)
        logger.success("Score assertions have passed.");
    }
    if (resolvedConfig.ci.reporter) {
      const reporter = resolvedConfig.ci.reporter;
      const payload = generateReportPayload(reporter, worker.reports());
      const path = relative(resolvedConfig.root, await outputReport(reporter, resolvedConfig, payload));
      logger.success(`Generated \`${resolvedConfig.ci.reporter}\` report \`./${path}\``);
    }
    if (resolvedConfig.ci?.buildStatic) {
      logger.info("Generating static report.");
      const { runtimeSettings, resolvedConfig: resolvedConfig2 } = useUnlighthouse();
      await generateClient({ static: true });
      const globby = await import('globby');
      const jsonPayloads = await globby.globby(
        ["lighthouse.json", "**/lighthouse.json", "assets/lighthouse.fbx"],
        { cwd: runtimeSettings.generatedClientPath, absolute: true }
      );
      logger.debug(
        `Deleting ${jsonPayloads.length} files not required for static build.`
      );
      for (const k in jsonPayloads)
        await fse.rm(jsonPayloads[k]);
      const relativeDir = `./${relative(resolvedConfig2.root, runtimeSettings.generatedClientPath)}`;
      logger.success(`Static report is ready for uploading: \`${relativeDir}\``);
      if (!isCI) {
        logger.info(`You can preview the static report using \`npx sirv-cli ${relativeDir}\`.`);
        logger.info("For deployment demos, see https://unlighthouse.com/docs/deployment");
      }
    }
    process.exit(0);
  });
}
run().catch(handleError);
