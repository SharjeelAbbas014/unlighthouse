import { useUnrouted, resolveStackPrefix, registerRoute, defineUnroutedPreset } from '@unrouted/core';
import { watchExports, untypedPayloads, generateTypes } from '@unrouted/plugins';
import { join } from 'pathe';
import compression from 'compression';
import { dynamicEventHandler, fromNodeMiddleware } from 'h3';
import sirv from 'sirv';
import { withBase, withTrailingSlash, withLeadingSlash, withoutTrailingSlash } from 'ufo';
import { defu } from 'defu';

const name = "@unrouted/preset-node";
const version = "0.5.0";

const serve = (path, dirname, sirvOptions = {}) => {
  const ctx = useUnrouted();
  sirvOptions = defu(sirvOptions, {
    single: true,
    dev: true
  });
  path = withBase(path, resolveStackPrefix());
  path = withTrailingSlash(withLeadingSlash(path));
  const serveArguments = {
    path,
    dirname,
    sirvOptions
  };
  ctx.hooks.callHook("serve:register", serveArguments).then(() => {
    const handle = dynamicEventHandler(async (e) => {
      const req = e.node.req;
      const res = e.node.res;
      if (serveArguments.path && serveArguments.path !== "/")
        req.url = withTrailingSlash(req.url?.replace(serveArguments.path, "") || "/");
      await ctx.hooks.callHook("serve:before-route", req);
      return new Promise((resolve) => {
        sirv(serveArguments.dirname, serveArguments.sirvOptions)(req, res, resolve);
      });
    });
    registerRoute("get", `${serveArguments.path}**`, handle);
    registerRoute("get", withoutTrailingSlash(serveArguments.path), handle);
  });
};

const presetNode = defineUnroutedPreset({
  meta: {
    name,
    version
  },
  defaults() {
    return {
      overrideUnroutedModule: true,
      generateTypes: true,
      generateTypesPath: join(process.cwd(), ".unrouted", "types.d.ts"),
      watchRouteExportsPattern: "**/*.{ts,mjs,js,cjs}"
    };
  },
  async setup(ctx, options) {
    ctx.config.middleware.push(fromNodeMiddleware(compression(options.compression)));
    if (options.watchRouteExportsPath) {
      ctx.config.plugins.push(watchExports({
        setupRoutesPath: options.setupRoutesPath,
        routesPath: options.watchRouteExportsPath,
        pattern: options.watchRouteExportsPattern
      }));
    }
    if (options.generateTypes) {
      ctx.config.plugins.push(untypedPayloads());
      ctx.config.plugins.push(generateTypes({
        declareModule: options.overrideUnroutedModule,
        outputPath: options.generateTypesPath
      }));
    }
  }
});

export { presetNode, serve };
