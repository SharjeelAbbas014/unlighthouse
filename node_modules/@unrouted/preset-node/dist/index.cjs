'use strict';

const core = require('@unrouted/core');
const plugins = require('@unrouted/plugins');
const pathe = require('pathe');
const compression = require('compression');
const h3 = require('h3');
const sirv = require('sirv');
const ufo = require('ufo');
const defu = require('defu');

const name = "@unrouted/preset-node";
const version = "0.5.0";

const serve = (path, dirname, sirvOptions = {}) => {
  const ctx = core.useUnrouted();
  sirvOptions = defu.defu(sirvOptions, {
    single: true,
    dev: true
  });
  path = ufo.withBase(path, core.resolveStackPrefix());
  path = ufo.withTrailingSlash(ufo.withLeadingSlash(path));
  const serveArguments = {
    path,
    dirname,
    sirvOptions
  };
  ctx.hooks.callHook("serve:register", serveArguments).then(() => {
    const handle = h3.dynamicEventHandler(async (e) => {
      const req = e.node.req;
      const res = e.node.res;
      if (serveArguments.path && serveArguments.path !== "/")
        req.url = ufo.withTrailingSlash(req.url?.replace(serveArguments.path, "") || "/");
      await ctx.hooks.callHook("serve:before-route", req);
      return new Promise((resolve) => {
        sirv(serveArguments.dirname, serveArguments.sirvOptions)(req, res, resolve);
      });
    });
    core.registerRoute("get", `${serveArguments.path}**`, handle);
    core.registerRoute("get", ufo.withoutTrailingSlash(serveArguments.path), handle);
  });
};

const presetNode = core.defineUnroutedPreset({
  meta: {
    name,
    version
  },
  defaults() {
    return {
      overrideUnroutedModule: true,
      generateTypes: true,
      generateTypesPath: pathe.join(process.cwd(), ".unrouted", "types.d.ts"),
      watchRouteExportsPattern: "**/*.{ts,mjs,js,cjs}"
    };
  },
  async setup(ctx, options) {
    ctx.config.middleware.push(h3.fromNodeMiddleware(compression(options.compression)));
    if (options.watchRouteExportsPath) {
      ctx.config.plugins.push(plugins.watchExports({
        setupRoutesPath: options.setupRoutesPath,
        routesPath: options.watchRouteExportsPath,
        pattern: options.watchRouteExportsPattern
      }));
    }
    if (options.generateTypes) {
      ctx.config.plugins.push(plugins.untypedPayloads());
      ctx.config.plugins.push(plugins.generateTypes({
        declareModule: options.overrideUnroutedModule,
        outputPath: options.generateTypesPath
      }));
    }
  }
});

exports.presetNode = presetNode;
exports.serve = serve;
