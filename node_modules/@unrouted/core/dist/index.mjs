import { createContext } from 'unctx';
import { eventHandler, sendRedirect as sendRedirect$1, readRawBody as readRawBody$1, getQuery, getMethod, parseCookies, setCookie as setCookie$1, sendError as sendError$1, appendHeader as appendHeader$1, assertMethod as assertMethod$1, isMethod as isMethod$1, deleteCookie as deleteCookie$1, readBody, createApp, createRouter } from 'h3';
import { createHooks } from 'hookable';
import consola from 'consola';
import { defu } from 'defu';
import { interopDefault } from 'mlly';
import { withBase, withLeadingSlash, withoutTrailingSlash } from 'ufo';
import { murmurHash } from 'ohash';

const createLogger = (key = "unrouted", debug = false) => {
  const logger = consola.withScope(key);
  if (debug) {
    logger.level = 4;
  }
  return logger;
};

const redirect = (route, location, code) => {
  registerRoute("get", route, eventHandler((e) => sendRedirect$1(e, location, code)));
};
const permanentRedirect = (route, location) => {
  registerRoute("get", route, eventHandler((e) => sendRedirect$1(e, location, 301)));
};

const match = (methods, route, handle) => registerRoute(methods, route, handle);
const any = (route, handle) => registerRoute(["get", "head", "post", "put", "delete", "connect", "options", "trace"], route, handle);
const get = (route, handle) => registerRoute(["get", "head"], route, handle);
const post = (route, handle) => registerRoute("post", route, handle);
const put = (route, handle) => registerRoute("put", route, handle);
const del = (route, handle) => registerRoute("delete", route, handle);
const head = (route, handle) => registerRoute("head", route, handle);
const options = (route, handle) => registerRoute("options", route, handle);

const group = (attributes, cb) => {
  const ctx = useUnrouted();
  if (attributes.controller)
    attributes.routeMeta = defu({ resolve: { module: attributes.controller } }, attributes?.routeMeta || {});
  ctx.groupStack.push(attributes);
  cb();
  ctx.groupStack.pop();
};
const middleware = (middleware2, cb) => {
  if (!Array.isArray(middleware2))
    middleware2 = [middleware2];
  return group({ routeMeta: { middleware: middleware2 } }, cb);
};
const prefix = (prefix2, cb) => {
  return group({ prefix: prefix2 }, cb);
};

function readRawBody(encoding) {
  return readRawBody$1(useEvent(), encoding);
}
function useQuery() {
  return getQuery(useEvent());
}
function useMethod(defaultMethod) {
  return getMethod(useEvent(), defaultMethod);
}
function useCookies() {
  return parseCookies(useEvent());
}
function setCookie(name, value, serializeOptions) {
  return setCookie$1(useEvent(), name, value, serializeOptions);
}
function sendRedirect(location, code) {
  return sendRedirect$1(useEvent(), location, code);
}
function sendError(error) {
  const { config } = useUnrouted();
  return sendError$1(useEvent(), error, config.debug);
}
function appendHeader(name, value) {
  return appendHeader$1(useEvent(), name, value);
}
function getHeader(name) {
  return useEvent().req.headers[name];
}
function assertMethod(expected, allowHead) {
  return assertMethod$1(useEvent(), expected, allowHead);
}
function isMethod(expected, allowHead) {
  return isMethod$1(useEvent(), expected, allowHead);
}
function deleteCookie(name, serializeOptions) {
  return deleteCookie$1(useEvent(), name, serializeOptions);
}

function setStatusCode(code) {
  const { res } = useEvent();
  res.statusCode = code;
}
function errorUnprocessableEntity(payload) {
  setStatusCode(422);
  return payload;
}
function errorNotFound(payload) {
  setStatusCode(404);
  return payload;
}

const normaliseSlashes = (s) => withLeadingSlash(withoutTrailingSlash(s));
const resolveStackPrefix = () => {
  const { groupStack } = useUnrouted();
  let path = "";
  for (const prefix of groupStack.filter((g) => !!g.prefix).map((g) => g.prefix).reverse()) {
    path = withBase(normaliseSlashes(path), prefix);
  }
  return path;
};
const resolveStackRouteMeta = () => {
  const { groupStack } = useUnrouted();
  let meta = {};
  for (const m of groupStack.filter((g) => !!g.routeMeta).map((g) => g.routeMeta).reverse()) {
    meta = defu(meta, m);
  }
  return meta;
};
function unroutedEventHandler(handle) {
  return eventHandler(async (e) => {
    const now = new Date().getTime();
    const { hooks, logger } = useUnrouted();
    await hooks.callHook("request:handle:before", e);
    const res = await handle(e);
    const timeTaken = new Date().getTime() - now;
    logger.debug(`\`${useMethod()} ${e.node.req.url}\` ${e.node.req.statusCode || 200} ${typeof res} - ${timeTaken}ms`);
    await hooks.callHook("response:before", handle, res);
    return res;
  });
}
const normaliseRoute = (method, path, handle, meta) => {
  path = withBase(normaliseSlashes(path), resolveStackPrefix());
  meta = defu(meta || {}, resolveStackRouteMeta());
  if (!Array.isArray(method))
    method = [method];
  const id = `_${murmurHash(`${method.join(",")} ${path}`)}`;
  meta.id = id;
  if (typeof handle === "function") {
    handle = unroutedEventHandler(handle);
    handle.__meta__ = meta;
  }
  return {
    id,
    path,
    handle,
    method,
    meta
  };
};
const registerRoute = (method, path, handle, options) => {
  const route = normaliseRoute(method, path, handle, options);
  const { routes, logger } = useUnrouted();
  if (routes.map((r) => r.path).includes(path)) {
    logger.debug("Skipping duplicate route registration");
    return route;
  }
  logger.debug(`Registering route \`${method}\` \`${route.path}\`.`);
  routes.push(route);
  return route;
};

function defineUnroutedPlugin(plugin) {
  return (options = {}) => {
    return {
      meta: plugin.meta,
      async setup(ctx) {
        let defaults = plugin.defaults || {};
        if (typeof plugin.defaults === "function")
          defaults = plugin.defaults(ctx);
        const resolvedOptions = defu(options, defaults);
        return await plugin.setup(ctx, resolvedOptions);
      }
    };
  };
}
function defineUnroutedPreset(preset) {
  return defineUnroutedPlugin(preset);
}
function defineUnroutedMiddleware(middleware) {
  return (options = {}) => {
    const m = defineUnroutedPlugin(middleware)(options);
    return m.setup(useUnrouted());
  };
}

const lazyRouteHandles = defineUnroutedPlugin({
  meta: {
    name: "lazyRouteHandles"
  },
  setup({ hooks, logger }) {
    hooks.hook("setup:routes", async (routes) => {
      for (const route of routes) {
        if (typeof route.handle === "function" && route.handle.name) {
          route.meta.resolve = {
            fn: route.handle.name
          };
        }
        if (typeof route.handle !== "string")
          continue;
        if (!route.meta.resolve?.module)
          continue;
        const module = interopDefault(await route.meta.resolve.module);
        if (!module[route.handle]) {
          logger.warn(`Missing method \`${route.handle}\` from controller ${module.__importMetaUrl}.`);
          continue;
        }
        route.meta.resolve.fn = route.handle;
        route.meta.resolve.file = module.__importMetaUrl;
        route.handle = unroutedEventHandler(module[route.handle]);
        route.handle.__meta__ = route.meta;
      }
    });
  }
});

function defineConfig(config) {
  return config;
}
const resolveConfig = async (config) => {
  config = defu(config, {
    debug: false,
    prefix: "/",
    middleware: [],
    hooks: {},
    plugins: [
      lazyRouteHandles()
    ],
    presets: [],
    name: "unrouted"
  });
  return config;
};

const eventCtx = createContext();
const unroutedCtx = createContext();
const useEvent = eventCtx.use;
const useUnrouted = unroutedCtx.use;
const paramCtx = createContext();
const bodyCtx = createContext();
const useParams = paramCtx.use;
const useBody = bodyCtx.use;
async function createUnrouted(config = {}) {
  const existingCtx = unroutedCtx.tryUse();
  if (existingCtx) {
    existingCtx.logger.debug("Not creating new unrouted instance, we already have an instance.");
    return existingCtx;
  }
  const resolvedConfig = await resolveConfig(config);
  const logger = createLogger(resolvedConfig.name, resolvedConfig.debug);
  logger.debug(`Creating new Unrouted ctx: \`${resolvedConfig.name}\``, resolvedConfig);
  const hooks = createHooks();
  if (config.hooks)
    hooks?.addHooks(config.hooks);
  hooks.hook("request:handle:before", async (e) => {
    eventCtx.set(e, true);
    const hasBody = ["PATCH", "POST", "PUT", "DELETE"].includes(useMethod());
    let body = null;
    if (hasBody)
      body = await readBody(e);
    bodyCtx.set(body || {}, true);
    paramCtx.set(e.context?.params || {}, true);
  });
  const app = config.app || createApp({
    async onError(err, event) {
      if (err.statusCode === 404)
        await hooks.callHook("request:error:404", event);
      await sendError$1(event, err, !!config.debug);
    }
  });
  const groupStack = [];
  if (resolvedConfig.prefix)
    groupStack.push({ prefix: resolvedConfig.prefix });
  const ctx = {
    app,
    hooks,
    logger,
    router: createRouter(),
    config: resolvedConfig,
    routes: [],
    groupStack
  };
  ctx.setup = async (fn) => {
    ctx.routes = [];
    await ctx.hooks.callHook("setup:before", ctx);
    if (fn)
      await unroutedCtx.call(ctx, fn);
    await ctx.hooks.callHook("setup:routes", ctx.routes);
    logger.debug(`Setting up ${ctx.routes.length} routes.`);
    ctx.routes.forEach((route) => {
      route.method.forEach((m) => {
        ctx.router.add(route.path, route.handle, m);
      });
    });
    await ctx.hooks.callHook("setup:after", ctx);
    if (typeof app.use === "function")
      app.use(ctx.router);
  };
  for (const preset of ctx.config.presets) {
    await preset.setup(ctx);
    logger.debug(`Using preset: \`${preset.meta.name}\`@\`${preset.meta.version}\``);
  }
  for (const plugin of ctx.config.plugins) {
    await plugin.setup(ctx);
    logger.debug(`Using plugin: \`${plugin.meta.name}\`${plugin.meta?.version ? `@\`${plugin.meta.version}\`` : ""}`);
  }
  for (const middleware of ctx.config.middleware) {
    if (typeof app.use === "function")
      app?.use(middleware);
  }
  unroutedCtx.set(ctx);
  return ctx;
}

export { any, appendHeader, assertMethod, createUnrouted, defineConfig, defineUnroutedMiddleware, defineUnroutedPlugin, defineUnroutedPreset, del, deleteCookie, errorNotFound, errorUnprocessableEntity, get, getHeader, group, head, isMethod, match, middleware, normaliseRoute, options, permanentRedirect, post, prefix, put, readRawBody, redirect, registerRoute, resolveConfig, resolveStackPrefix, resolveStackRouteMeta, sendError, sendRedirect, setCookie, setStatusCode, unroutedEventHandler, useBody, useCookies, useEvent, useMethod, useParams, useQuery, useUnrouted };
