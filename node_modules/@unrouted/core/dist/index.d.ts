import * as h3 from 'h3';
import { EventHandler, H3Event, App, Router, RouterMethod, CompatibilityEventHandler, HTTPMethod, H3Error } from 'h3';
import { Hookable } from 'hookable';
import { Consola } from 'consola';
import { Import } from 'unimport';
import { QueryObject } from 'ufo';

type Nullable$1<T> = {
    [K in keyof T]: T[K] | null;
};
type HookResult<T = void> = Promise<T> | T;
interface UnroutedHooks {
    'setup:after': (ctx: UnroutedContext) => HookResult;
    'setup:before': (ctx: UnroutedContext) => HookResult;
    'setup:routes': (routes: Route[]) => HookResult;
    'response:before': (handler: EventHandler, payload: any) => HookResult;
    'request:handle:before': (e: H3Event) => HookResult;
    'request:error:404': (e: H3Event) => HookResult;
}
type UnroutedEventHandler = EventHandler | string;
type UnroutedHookable = Hookable<UnroutedHooks>;
type SimpleOptions = Record<string, any>;
interface UnroutedPlugin<T> {
    defaults?: T extends any ? (Partial<T> | ((ctx: UnroutedContext) => Partial<T>)) : never;
    meta: {
        name: string;
        version?: string;
    };
    setup: (ctx: UnroutedContext, resolvedOptions: T) => Promise<any> | any;
}
interface UnroutedPreset<T> extends UnroutedPlugin<T> {
}
interface UnroutedMiddleware<T> extends UnroutedPlugin<T> {
}
interface ResolvedPlugin {
    meta: {
        name: string;
        version?: string;
    };
    setup: (ctx: UnroutedContext) => Promise<any> | any;
}
interface ResolvedConfig {
    app?: App;
    prefix: string;
    name: string;
    debug: boolean;
    presets: ResolvedPlugin[];
    plugins: ResolvedPlugin[];
    middleware: EventHandler[];
    hooks: Partial<UnroutedHooks>;
}
type DeepPartial<T> = T extends Function ? T : (T extends object ? {
    [P in keyof T]?: DeepPartial<T[P]>;
} : T);
type NormaliseRouteFn = (method: HttpMethodInput, urlPattern: string, handle: UnroutedEventHandler, meta?: RouteMeta) => Route;
type RegisterRouteFn = (method: HttpMethodInput, urlPattern: string, handle: UnroutedEventHandler, meta?: RouteMeta) => Route;
type ConfigPartial = DeepPartial<ResolvedConfig>;
interface GroupAttributes {
    middleware?: UnroutedEventHandler[];
    prefix?: string;
    controller?: any;
    routeMeta?: RouteMeta;
}
interface UnroutedContext {
    /**
     * Runtime configuration for the current prefix path.
     */
    groupStack: GroupAttributes[];
    /**
     * Resolved configuration.
     */
    config: ResolvedConfig;
    /**
     * Function used to handle a request for the Unrouted instance.
     * This should be passed to a server such as h3, connect, express, koa, etc.
     */
    app: App;
    /**
     * A flat copy of the normalised routes being used.
     */
    routes: Route[];
    router: Router;
    /**
     * The logger instance. Will be Consola if available, otherwise console.
     */
    logger: Consola;
    /**
     * The hookable instance, allows hooking into core functionality.
     */
    hooks: UnroutedHookable;
    /**
     * Composable setup function for declaring routes.
     * @param fn
     */
    setup: (fn?: () => void) => Promise<void>;
}
type HttpMethodInput = RouterMethod | RouterMethod[];
interface RouteMeta {
    id?: string;
    resolve?: {
        module?: unknown;
        file?: string;
        import?: Import;
        fn?: string;
    };
    middleware?: UnroutedEventHandler[];
    parameterMatchRegExps?: Record<string, RegExp>;
    runtimeTypes?: string;
}
interface Route {
    id: string;
    path: string;
    handle: UnroutedEventHandler;
    method: RouterMethod[];
    meta: RouteMeta;
}
interface GetRoutes {
}
interface PostRoutes {
}
interface PutRoutes {
}
interface PatchRoutes {
}
interface DeleteRoutes {
}
interface OptionsRoutes {
}
interface RouteSchema {
    get: GetRoutes;
    post: PostRoutes;
    put: PutRoutes;
    patch: PatchRoutes;
    delete: DeleteRoutes;
    options: OptionsRoutes;
}

declare const useEvent: () => H3Event;
declare const useUnrouted: () => UnroutedContext;
declare const useParams: <T>() => T;
declare const useBody: <T>() => Nullable$1<T>;
declare function createUnrouted(config?: ConfigPartial): Promise<UnroutedContext>;

/**
 * A simple define wrapper to provide typings to config definitions.
 * @param config
 */
declare function defineConfig(config: ConfigPartial): {
    app?: {
        stack?: ({
            route?: string | undefined;
            match?: h3.Matcher | undefined;
            handler?: h3.EventHandler<any> | undefined;
        } | undefined)[] | undefined;
        handler?: h3.EventHandler<any> | undefined;
        options?: {
            debug?: boolean | undefined;
            onError?: ((error: Error, event: h3.H3Event) => any) | undefined;
        } | undefined;
        use?: h3.AppUse | undefined;
    } | undefined;
    prefix?: string | undefined;
    name?: string | undefined;
    debug?: boolean | undefined;
    presets?: ({
        meta?: {
            name?: string | undefined;
            version?: string | undefined;
        } | undefined;
        setup?: ((ctx: UnroutedContext) => any) | undefined;
    } | undefined)[] | undefined;
    plugins?: ({
        meta?: {
            name?: string | undefined;
            version?: string | undefined;
        } | undefined;
        setup?: ((ctx: UnroutedContext) => any) | undefined;
    } | undefined)[] | undefined;
    middleware?: (h3.EventHandler<any> | undefined)[] | undefined;
    hooks?: {
        'setup:after'?: ((ctx: UnroutedContext) => HookResult<void>) | undefined;
        'setup:before'?: ((ctx: UnroutedContext) => HookResult<void>) | undefined;
        'setup:routes'?: ((routes: Route[]) => HookResult<void>) | undefined;
        'response:before'?: ((handler: h3.EventHandler<any>, payload: any) => HookResult<void>) | undefined;
        'request:handle:before'?: ((e: h3.H3Event) => HookResult<void>) | undefined;
        'request:error:404'?: ((e: h3.H3Event) => HookResult<void>) | undefined;
    } | undefined;
};
/**
 * A provided configuration from the user may require runtime transformations to avoid breaking app functionality.
 * @param config
 */
declare const resolveConfig: (config: ConfigPartial) => Promise<ResolvedConfig>;

declare function defineUnroutedPlugin<T extends SimpleOptions = SimpleOptions>(plugin: UnroutedPlugin<T>): (options?: Partial<T>) => ResolvedPlugin;
declare function defineUnroutedPreset<T extends SimpleOptions = SimpleOptions>(preset: UnroutedPreset<T>): (options?: Partial<T> | undefined) => ResolvedPlugin;
declare function defineUnroutedMiddleware<T extends SimpleOptions = SimpleOptions>(middleware: UnroutedMiddleware<T>): (options?: Partial<T>) => CompatibilityEventHandler;

declare const resolveStackPrefix: () => string;
declare const resolveStackRouteMeta: () => {};
declare function unroutedEventHandler(handle: any): EventHandler;
/**
 * Create a normalised route from numerous inputs.
 */
declare const normaliseRoute: NormaliseRouteFn;
/**
 * Registers a route with our router.
 *
 * The route is registered asynchronously to allow for plugins to hook into the registration. This means the route won't
 * be immediately available within the Unrouter context.
 */
declare const registerRoute: RegisterRouteFn;

declare const redirect: (route: string, location: string, code?: 301 | 302 | 307 | 410 | 451) => void;
declare const permanentRedirect: (route: string, location: string) => void;

type MatchFn = (methods: RouterMethod, route: string, handle: UnroutedEventHandler) => void;
type RouteMethod = (route: string, handle: UnroutedEventHandler) => Route;
declare const match: MatchFn;
declare const any: RouteMethod;
declare const get: RouteMethod;
declare const post: RouteMethod;
declare const put: RouteMethod;
declare const del: RouteMethod;
declare const head: RouteMethod;
declare const options: RouteMethod;

declare const group: (attributes: GroupAttributes, cb: (() => void)) => void;
declare const middleware: (middleware: EventHandler[], cb: (() => void)) => void;
declare const prefix: (prefix: string, cb: (() => void)) => void;

type Nullable<T> = {
    [K in keyof T]: T[K] | undefined;
};
declare function readRawBody(encoding?: false | 'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'latin1' | 'binary' | 'hex'): Promise<string | Buffer | undefined>;
declare function useQuery<T extends QueryObject>(): Nullable<T>;
declare function useMethod(defaultMethod?: HTTPMethod): HTTPMethod;
declare function useCookies(): Record<string, string>;
declare function setCookie(name: string, value: string, serializeOptions?: any): void;
declare function sendRedirect(location: string, code?: number): Promise<void>;
declare function sendError(error: Error | H3Error): void;
declare function appendHeader(name: string, value: string): void;
declare function getHeader(name: string): string | string[] | undefined;
declare function assertMethod(expected: HTTPMethod | HTTPMethod[], allowHead?: boolean): void;
declare function isMethod(expected: HTTPMethod | HTTPMethod[], allowHead?: boolean): boolean;
declare function deleteCookie(name: string, serializeOptions?: any): void;

declare function setStatusCode(code: number): void;
declare function errorUnprocessableEntity(payload: any): any;
declare function errorNotFound(payload: any): any;

export { ConfigPartial, DeepPartial, DeleteRoutes, GetRoutes, GroupAttributes, HookResult, HttpMethodInput, NormaliseRouteFn, Nullable$1 as Nullable, OptionsRoutes, PatchRoutes, PostRoutes, PutRoutes, RegisterRouteFn, ResolvedConfig, ResolvedPlugin, Route, RouteMeta, RouteSchema, SimpleOptions, UnroutedContext, UnroutedEventHandler, UnroutedHookable, UnroutedHooks, UnroutedMiddleware, UnroutedPlugin, UnroutedPreset, any, appendHeader, assertMethod, createUnrouted, defineConfig, defineUnroutedMiddleware, defineUnroutedPlugin, defineUnroutedPreset, del, deleteCookie, errorNotFound, errorUnprocessableEntity, get, getHeader, group, head, isMethod, match, middleware, normaliseRoute, options, permanentRedirect, post, prefix, put, readRawBody, redirect, registerRoute, resolveConfig, resolveStackPrefix, resolveStackRouteMeta, sendError, sendRedirect, setCookie, setStatusCode, unroutedEventHandler, useBody, useCookies, useEvent, useMethod, useParams, useQuery, useUnrouted };
