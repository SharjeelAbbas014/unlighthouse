'use strict';

const unctx = require('unctx');
const h3 = require('h3');
const hookable = require('hookable');
const consola = require('consola');
const defu = require('defu');
const mlly = require('mlly');
const ufo = require('ufo');
const ohash = require('ohash');

const createLogger = (key = "unrouted", debug = false) => {
  const logger = consola.withScope(key);
  if (debug) {
    logger.level = 4;
  }
  return logger;
};

const redirect = (route, location, code) => {
  registerRoute("get", route, h3.eventHandler((e) => h3.sendRedirect(e, location, code)));
};
const permanentRedirect = (route, location) => {
  registerRoute("get", route, h3.eventHandler((e) => h3.sendRedirect(e, location, 301)));
};

const match = (methods, route, handle) => registerRoute(methods, route, handle);
const any = (route, handle) => registerRoute(["get", "head", "post", "put", "delete", "connect", "options", "trace"], route, handle);
const get = (route, handle) => registerRoute(["get", "head"], route, handle);
const post = (route, handle) => registerRoute("post", route, handle);
const put = (route, handle) => registerRoute("put", route, handle);
const del = (route, handle) => registerRoute("delete", route, handle);
const head = (route, handle) => registerRoute("head", route, handle);
const options = (route, handle) => registerRoute("options", route, handle);

const group = (attributes, cb) => {
  const ctx = useUnrouted();
  if (attributes.controller)
    attributes.routeMeta = defu.defu({ resolve: { module: attributes.controller } }, attributes?.routeMeta || {});
  ctx.groupStack.push(attributes);
  cb();
  ctx.groupStack.pop();
};
const middleware = (middleware2, cb) => {
  if (!Array.isArray(middleware2))
    middleware2 = [middleware2];
  return group({ routeMeta: { middleware: middleware2 } }, cb);
};
const prefix = (prefix2, cb) => {
  return group({ prefix: prefix2 }, cb);
};

function readRawBody(encoding) {
  return h3.readRawBody(useEvent(), encoding);
}
function useQuery() {
  return h3.getQuery(useEvent());
}
function useMethod(defaultMethod) {
  return h3.getMethod(useEvent(), defaultMethod);
}
function useCookies() {
  return h3.parseCookies(useEvent());
}
function setCookie(name, value, serializeOptions) {
  return h3.setCookie(useEvent(), name, value, serializeOptions);
}
function sendRedirect(location, code) {
  return h3.sendRedirect(useEvent(), location, code);
}
function sendError(error) {
  const { config } = useUnrouted();
  return h3.sendError(useEvent(), error, config.debug);
}
function appendHeader(name, value) {
  return h3.appendHeader(useEvent(), name, value);
}
function getHeader(name) {
  return useEvent().req.headers[name];
}
function assertMethod(expected, allowHead) {
  return h3.assertMethod(useEvent(), expected, allowHead);
}
function isMethod(expected, allowHead) {
  return h3.isMethod(useEvent(), expected, allowHead);
}
function deleteCookie(name, serializeOptions) {
  return h3.deleteCookie(useEvent(), name, serializeOptions);
}

function setStatusCode(code) {
  const { res } = useEvent();
  res.statusCode = code;
}
function errorUnprocessableEntity(payload) {
  setStatusCode(422);
  return payload;
}
function errorNotFound(payload) {
  setStatusCode(404);
  return payload;
}

const normaliseSlashes = (s) => ufo.withLeadingSlash(ufo.withoutTrailingSlash(s));
const resolveStackPrefix = () => {
  const { groupStack } = useUnrouted();
  let path = "";
  for (const prefix of groupStack.filter((g) => !!g.prefix).map((g) => g.prefix).reverse()) {
    path = ufo.withBase(normaliseSlashes(path), prefix);
  }
  return path;
};
const resolveStackRouteMeta = () => {
  const { groupStack } = useUnrouted();
  let meta = {};
  for (const m of groupStack.filter((g) => !!g.routeMeta).map((g) => g.routeMeta).reverse()) {
    meta = defu.defu(meta, m);
  }
  return meta;
};
function unroutedEventHandler(handle) {
  return h3.eventHandler(async (e) => {
    const now = new Date().getTime();
    const { hooks, logger } = useUnrouted();
    await hooks.callHook("request:handle:before", e);
    const res = await handle(e);
    const timeTaken = new Date().getTime() - now;
    logger.debug(`\`${useMethod()} ${e.node.req.url}\` ${e.node.req.statusCode || 200} ${typeof res} - ${timeTaken}ms`);
    await hooks.callHook("response:before", handle, res);
    return res;
  });
}
const normaliseRoute = (method, path, handle, meta) => {
  path = ufo.withBase(normaliseSlashes(path), resolveStackPrefix());
  meta = defu.defu(meta || {}, resolveStackRouteMeta());
  if (!Array.isArray(method))
    method = [method];
  const id = `_${ohash.murmurHash(`${method.join(",")} ${path}`)}`;
  meta.id = id;
  if (typeof handle === "function") {
    handle = unroutedEventHandler(handle);
    handle.__meta__ = meta;
  }
  return {
    id,
    path,
    handle,
    method,
    meta
  };
};
const registerRoute = (method, path, handle, options) => {
  const route = normaliseRoute(method, path, handle, options);
  const { routes, logger } = useUnrouted();
  if (routes.map((r) => r.path).includes(path)) {
    logger.debug("Skipping duplicate route registration");
    return route;
  }
  logger.debug(`Registering route \`${method}\` \`${route.path}\`.`);
  routes.push(route);
  return route;
};

function defineUnroutedPlugin(plugin) {
  return (options = {}) => {
    return {
      meta: plugin.meta,
      async setup(ctx) {
        let defaults = plugin.defaults || {};
        if (typeof plugin.defaults === "function")
          defaults = plugin.defaults(ctx);
        const resolvedOptions = defu.defu(options, defaults);
        return await plugin.setup(ctx, resolvedOptions);
      }
    };
  };
}
function defineUnroutedPreset(preset) {
  return defineUnroutedPlugin(preset);
}
function defineUnroutedMiddleware(middleware) {
  return (options = {}) => {
    const m = defineUnroutedPlugin(middleware)(options);
    return m.setup(useUnrouted());
  };
}

const lazyRouteHandles = defineUnroutedPlugin({
  meta: {
    name: "lazyRouteHandles"
  },
  setup({ hooks, logger }) {
    hooks.hook("setup:routes", async (routes) => {
      for (const route of routes) {
        if (typeof route.handle === "function" && route.handle.name) {
          route.meta.resolve = {
            fn: route.handle.name
          };
        }
        if (typeof route.handle !== "string")
          continue;
        if (!route.meta.resolve?.module)
          continue;
        const module = mlly.interopDefault(await route.meta.resolve.module);
        if (!module[route.handle]) {
          logger.warn(`Missing method \`${route.handle}\` from controller ${module.__importMetaUrl}.`);
          continue;
        }
        route.meta.resolve.fn = route.handle;
        route.meta.resolve.file = module.__importMetaUrl;
        route.handle = unroutedEventHandler(module[route.handle]);
        route.handle.__meta__ = route.meta;
      }
    });
  }
});

function defineConfig(config) {
  return config;
}
const resolveConfig = async (config) => {
  config = defu.defu(config, {
    debug: false,
    prefix: "/",
    middleware: [],
    hooks: {},
    plugins: [
      lazyRouteHandles()
    ],
    presets: [],
    name: "unrouted"
  });
  return config;
};

const eventCtx = unctx.createContext();
const unroutedCtx = unctx.createContext();
const useEvent = eventCtx.use;
const useUnrouted = unroutedCtx.use;
const paramCtx = unctx.createContext();
const bodyCtx = unctx.createContext();
const useParams = paramCtx.use;
const useBody = bodyCtx.use;
async function createUnrouted(config = {}) {
  const existingCtx = unroutedCtx.tryUse();
  if (existingCtx) {
    existingCtx.logger.debug("Not creating new unrouted instance, we already have an instance.");
    return existingCtx;
  }
  const resolvedConfig = await resolveConfig(config);
  const logger = createLogger(resolvedConfig.name, resolvedConfig.debug);
  logger.debug(`Creating new Unrouted ctx: \`${resolvedConfig.name}\``, resolvedConfig);
  const hooks = hookable.createHooks();
  if (config.hooks)
    hooks?.addHooks(config.hooks);
  hooks.hook("request:handle:before", async (e) => {
    eventCtx.set(e, true);
    const hasBody = ["PATCH", "POST", "PUT", "DELETE"].includes(useMethod());
    let body = null;
    if (hasBody)
      body = await h3.readBody(e);
    bodyCtx.set(body || {}, true);
    paramCtx.set(e.context?.params || {}, true);
  });
  const app = config.app || h3.createApp({
    async onError(err, event) {
      if (err.statusCode === 404)
        await hooks.callHook("request:error:404", event);
      await h3.sendError(event, err, !!config.debug);
    }
  });
  const groupStack = [];
  if (resolvedConfig.prefix)
    groupStack.push({ prefix: resolvedConfig.prefix });
  const ctx = {
    app,
    hooks,
    logger,
    router: h3.createRouter(),
    config: resolvedConfig,
    routes: [],
    groupStack
  };
  ctx.setup = async (fn) => {
    ctx.routes = [];
    await ctx.hooks.callHook("setup:before", ctx);
    if (fn)
      await unroutedCtx.call(ctx, fn);
    await ctx.hooks.callHook("setup:routes", ctx.routes);
    logger.debug(`Setting up ${ctx.routes.length} routes.`);
    ctx.routes.forEach((route) => {
      route.method.forEach((m) => {
        ctx.router.add(route.path, route.handle, m);
      });
    });
    await ctx.hooks.callHook("setup:after", ctx);
    if (typeof app.use === "function")
      app.use(ctx.router);
  };
  for (const preset of ctx.config.presets) {
    await preset.setup(ctx);
    logger.debug(`Using preset: \`${preset.meta.name}\`@\`${preset.meta.version}\``);
  }
  for (const plugin of ctx.config.plugins) {
    await plugin.setup(ctx);
    logger.debug(`Using plugin: \`${plugin.meta.name}\`${plugin.meta?.version ? `@\`${plugin.meta.version}\`` : ""}`);
  }
  for (const middleware of ctx.config.middleware) {
    if (typeof app.use === "function")
      app?.use(middleware);
  }
  unroutedCtx.set(ctx);
  return ctx;
}

exports.any = any;
exports.appendHeader = appendHeader;
exports.assertMethod = assertMethod;
exports.createUnrouted = createUnrouted;
exports.defineConfig = defineConfig;
exports.defineUnroutedMiddleware = defineUnroutedMiddleware;
exports.defineUnroutedPlugin = defineUnroutedPlugin;
exports.defineUnroutedPreset = defineUnroutedPreset;
exports.del = del;
exports.deleteCookie = deleteCookie;
exports.errorNotFound = errorNotFound;
exports.errorUnprocessableEntity = errorUnprocessableEntity;
exports.get = get;
exports.getHeader = getHeader;
exports.group = group;
exports.head = head;
exports.isMethod = isMethod;
exports.match = match;
exports.middleware = middleware;
exports.normaliseRoute = normaliseRoute;
exports.options = options;
exports.permanentRedirect = permanentRedirect;
exports.post = post;
exports.prefix = prefix;
exports.put = put;
exports.readRawBody = readRawBody;
exports.redirect = redirect;
exports.registerRoute = registerRoute;
exports.resolveConfig = resolveConfig;
exports.resolveStackPrefix = resolveStackPrefix;
exports.resolveStackRouteMeta = resolveStackRouteMeta;
exports.sendError = sendError;
exports.sendRedirect = sendRedirect;
exports.setCookie = setCookie;
exports.setStatusCode = setStatusCode;
exports.unroutedEventHandler = unroutedEventHandler;
exports.useBody = useBody;
exports.useCookies = useCookies;
exports.useEvent = useEvent;
exports.useMethod = useMethod;
exports.useParams = useParams;
exports.useQuery = useQuery;
exports.useUnrouted = useUnrouted;
