import { defineUnroutedPlugin, useUnrouted } from '@unrouted/core';
import fse from 'fs-extra';
import { relative, dirname } from 'pathe';
import { scanDirExports } from 'unimport';
import { generateTypes as generateTypes$1, resolveSchema } from 'untyped';

const LaravelNamedParamRegex = /{([\w]*?)}/gm;
const laravelNamedParams = defineUnroutedPlugin({
  meta: {
    name: "laravelNamedParams"
  },
  setup({ hooks }) {
    hooks.hook("setup:routes", (routes) => {
      for (const route of routes)
        route.path = route.path.replace(LaravelNamedParamRegex, ":$1");
    });
  }
});

const ucFirst = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function generateMethodStack(routes) {
  const methodStack = {};
  routes.forEach((route) => {
    route.method.forEach((method) => {
      if (!methodStack[method])
        methodStack[method] = [];
      methodStack[method].push(route);
    });
  });
  return methodStack;
}
async function exportFetchTypes(ctx, pluginConfig) {
  const { routes } = ctx;
  const methodStack = generateMethodStack(routes);
  let types = "// Generated by unrouted\n";
  types += "declare module '@unrouted/core' {\n";
  types += "  type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T\n";
  routes.forEach((r) => {
    if (r.meta.runtimeTypes && r.meta.runtimeTypes.includes("interface"))
      types += `${r.meta.runtimeTypes}

`;
  });
  for (const m in methodStack) {
    const method = m;
    const requests = methodStack[method];
    if (requests.length === 0)
      continue;
    const name = ucFirst(method.toLowerCase());
    const typeName = `${name}Routes`;
    types += `  interface ${typeName} {
`;
    const routeTypes = [];
    for (const route of methodStack[method]) {
      let path = route.path;
      if (path.match(/:(\w+)/) || path.endsWith("**")) {
        path = path.replace(/:(\w+)/, "${string}").replace(/\*\*/, "${string}");
        path = `[key: \`${path}\`]`;
      } else {
        path = `'${path}'`;
      }
      let imp = "Awaited<ReturnType<unknown>>";
      if (route.meta.resolve?.file) {
        const relativePath = relative(dirname(pluginConfig.outputPath), route.meta.resolve?.file).replace(/\.[^/.]+$/, "");
        imp = `Awaited<ReturnType<typeof import('${relativePath}').${route.meta.resolve?.fn}>>`;
      } else if (route.meta.resolve?.import) {
        const relativePath = relative(dirname(pluginConfig.outputPath), route.meta.resolve?.import.from).replace(/\.[^/.]+$/, "");
        imp = `Awaited<ReturnType<typeof import('${relativePath}').${route.meta.resolve.import.as}>>`;
      } else if (route.meta.runtimeTypes) {
        imp = `Awaited<${route.meta.runtimeTypes.includes("interface") ? route.id : route.meta.runtimeTypes}>`;
      }
      routeTypes.push(`    ${path}: ${imp}`);
    }
    types += `${routeTypes.join("\n")}
  }
`;
  }
  types += "}\n\n";
  types += "export {}\n";
  await fse.outputFile(pluginConfig.outputPath, types, { encoding: "utf-8" });
}
async function exportSimpleTypes(ctx, pluginConfig) {
  const { routes } = ctx;
  const methodStack = generateMethodStack(routes);
  let types = "// Generated by unrouted\n";
  types += "export interface RouteSchema {\n";
  for (const m in methodStack) {
    const method = m;
    const requests = methodStack[method];
    if (requests.length === 0)
      continue;
    types += `  ${method}:`;
    const routeTypes = [];
    for (const route of methodStack[method]) {
      let path = route.path;
      if (path.match(/:(\w+)/) || path.endsWith("**")) {
        path = path.replace(/:(\w+)/, "${string}").replace(/\*\*/, "${string}");
        routeTypes.push(`  \`${path}\``);
      } else {
        routeTypes.push(`  '${path}'`);
      }
    }
    types += `${routeTypes.join("|\n")}

`;
  }
  types += "}\n";
  await fse.outputFile(pluginConfig.outputPath, types, { encoding: "utf-8" });
}
const generateTypes = defineUnroutedPlugin({
  meta: {
    name: "generateTypes"
  },
  defaults: {
    declareModule: true
  },
  setup({ hooks }, config) {
    hooks.hook("setup:after", async (ctx) => {
      if (config.declareModule)
        await exportFetchTypes(ctx, config);
      else
        await exportSimpleTypes(ctx, config);
    });
    hooks.hook("response:before", async (handle) => {
      if (handle.__meta__?.runtimeTypes) {
        const ctx = useUnrouted();
        if (config.declareModule)
          await exportFetchTypes(ctx, config);
        else
          await exportSimpleTypes(ctx, config);
      }
    });
  }
});

const watchExports = defineUnroutedPlugin({
  meta: {
    name: "watchExports"
  },
  defaults: {
    pattern: "**/*.{ts,mjs,js,cjs}"
  },
  async setup({ hooks }, options) {
    const mappedRouteExports = {};
    hooks.hook("setup:before", async () => {
      const imports = await scanDirExports(options.routesPath, {
        filePatterns: [options.pattern]
      });
      imports.forEach((e) => {
        mappedRouteExports[e.name] = e;
      });
    });
    hooks.hook("setup:after", async ({ routes }) => {
      for (const r of routes) {
        if (!r.meta.resolve?.fn)
          continue;
        if (r.meta.resolve?.file)
          continue;
        if (mappedRouteExports[r.meta.resolve.fn])
          r.meta.resolve.import = mappedRouteExports[r.meta.resolve.fn];
      }
    });
  }
});

function untypePayload(payload, options) {
  if (typeof payload === "string")
    return `'${payload}'|${typeof payload}`;
  if (typeof payload === "number")
    return `${payload}|${typeof payload}`;
  return generateTypes$1(resolveSchema(payload), options);
}

const untypedPayloads = defineUnroutedPlugin({
  meta: {
    name: "untypedPayloads"
  },
  async setup({ hooks }) {
    hooks.hook("response:before", async (event, payload) => {
      const meta = event.__meta__;
      if (!meta || meta.resolve?.file || meta.runtimeTypes)
        return;
      meta.runtimeTypes = untypePayload(payload, {
        interfaceName: meta.id,
        indentation: 2,
        addDefaults: false,
        addExport: false
      });
    });
  }
});

export { generateTypes, laravelNamedParams, untypedPayloads, watchExports };
